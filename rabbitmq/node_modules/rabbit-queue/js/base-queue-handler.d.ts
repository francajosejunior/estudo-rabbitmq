import Rabbit from './rabbit';
import * as amqp from 'amqplib';
import Queue from './queue';
import getLogger from './logger';
declare abstract class BaseQueueHandler {
    queueName: any;
    rabbit: Rabbit;
    dlqName: string;
    retries: number;
    retryDelay: number;
    logger: ReturnType<typeof getLogger>;
    queue: Queue;
    dlq: Queue;
    logEnabled: boolean;
    created: Promise<void>;
    scope: 'SINGLETON' | 'PROTOTYPE';
    prefetch?: number;
    static SCOPES: {
        singleton: 'SINGLETON';
        prototype: 'PROTOTYPE';
    };
    constructor(queueName: any, rabbit: Rabbit, { retries, retryDelay, logEnabled, scope, createAndSubscribeToQueue, prefetch, }?: {
        retries?: number;
        retryDelay?: number;
        logEnabled?: boolean;
        scope?: "SINGLETON" | "PROTOTYPE";
        createAndSubscribeToQueue?: boolean;
        prefetch?: number;
    });
    getDlq(): string;
    getCorrelationId(msg: amqp.Message, event?: any): any;
    getQueueOptions(): {};
    getDlqOptions(): any;
    static prototypeFactory<T extends BaseQueueHandler>(queueName: any, rabbit: Rabbit, options?: {}): T;
    createQueues(): Promise<void>;
    tryHandle(retries: any, msg: amqp.Message, ack: (error: any, reply: any) => any): Promise<void>;
    handleError(err: any, msg: any): void;
    getTime(): number;
    logTime(startTime: number, correlationId: string): void;
    setTimeout(time: any): Promise<unknown>;
    retry(retries: any, msg: any, ack: any): Promise<void>;
    abstract handle(data: {
        msg: amqp.Message;
        event: any;
        correlationId: string;
        startTime: number;
    }): any;
    afterDlq(data: {
        msg: amqp.Message;
        event: any;
    }): void;
    addToDLQ(retries: any, msg: amqp.Message, ack: any): Promise<void>;
}
export default BaseQueueHandler;
