"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const encode_decode_1 = require("./encode-decode");
const logger_1 = require("./logger");
class BaseQueueHandler {
    constructor(queueName, rabbit, { retries = 3, retryDelay = 1000, logEnabled = true, scope = BaseQueueHandler.SCOPES.singleton, createAndSubscribeToQueue = true, prefetch = rabbit.prefetch, } = {}) {
        this.queueName = queueName;
        this.rabbit = rabbit;
        const logger = logger_1.default(`rabbit-queue.${queueName}`);
        this.prefetch = prefetch;
        this.retries = retries;
        this.retryDelay = retryDelay;
        this.logger = logger;
        this.logEnabled = logEnabled;
        this.scope = scope;
        this.dlqName = this.getDlq();
        if (createAndSubscribeToQueue) {
            this.created = this.createQueues();
        }
    }
    getDlq() {
        return this.queueName + '_dlq';
    }
    getCorrelationId(msg, event) {
        return msg.properties.correlationId;
    }
    getQueueOptions() {
        return {};
    }
    getDlqOptions() {
        return undefined;
    }
    static prototypeFactory(queueName, rabbit, options = {}) {
        const Constructor = this;
        const instance = new Constructor(queueName, rabbit, Object.assign(Object.assign({}, options), { scope: BaseQueueHandler.SCOPES.prototype }));
        return instance;
    }
    createQueues() {
        return __awaiter(this, void 0, void 0, function* () {
            this.queue = yield this.rabbit
                .createQueue(this.queueName, Object.assign(Object.assign({}, this.getQueueOptions()), { prefetch: this.prefetch }), (msg, ack) => {
                if (this.scope === BaseQueueHandler.SCOPES.singleton) {
                    this.tryHandle(0, msg, ack).catch((e) => this.logger.error(e));
                }
                else {
                    const instance = new this.constructor(this.queueName, this.rabbit, {
                        retries: this.retries,
                        retryDelay: this.retryDelay,
                        logger: this.logger,
                        logEnabled: this.logEnabled,
                        scope: this.scope,
                        createAndSubscribeToQueue: false,
                    });
                    instance.tryHandle(0, msg, ack).catch((e) => this.logger.error(e));
                }
            })
                .catch((error) => this.logger.error(error));
            this.dlq = yield this.rabbit
                .createQueue(this.dlqName, this.getDlqOptions())
                .catch((error) => this.logger.error(error));
        });
    }
    tryHandle(retries, msg, ack) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const startTime = this.getTime();
                const event = encode_decode_1.decode(msg);
                const correlationId = this.getCorrelationId(msg, event);
                this.logger.debug(`[${correlationId}] #${retries + 1} Dequeueing ${this.queueName} `);
                const result = yield this.handle({ msg, event, correlationId, startTime });
                this.logger.debug(`[${correlationId}] #${retries + 1} Acknowledging ${this.queueName} `);
                ack(null, result);
                if (this.logEnabled) {
                    this.logTime(startTime, correlationId);
                }
            }
            catch (err) {
                this.handleError(err, msg);
                this.retry(retries, msg, ack).catch((error) => this.logger.error(error));
            }
        });
    }
    handleError(err, msg) {
        this.logger.error(err);
        msg.properties.headers.errors = {
            name: err.name && err.name.substr(0, 200),
            message: err.message && err.message.substr(0, 200),
            stack: err.stack && err.stack.substr(0, 200),
            time: new Date().toString(),
        };
    }
    getTime() {
        return new Date().getTime();
    }
    logTime(startTime, correlationId) {
        this.logger.debug(`[${correlationId}] Queue processing took ${new Date().getTime() - startTime} ms`);
    }
    setTimeout(time) {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, time);
        });
    }
    retry(retries, msg, ack) {
        return __awaiter(this, void 0, void 0, function* () {
            if (retries < this.retries) {
                this.logger.debug('will retry');
                yield this.setTimeout(this.retryDelay);
                yield this.tryHandle(retries + 1, msg, ack);
            }
            else {
                yield this.addToDLQ(retries, msg, ack);
            }
        });
    }
    afterDlq(data) {
        this.logger.info(`[${this.getCorrelationId(data.msg)}] Added to dlq`);
    }
    addToDLQ(retries, msg, ack) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const correlationId = this.getCorrelationId(msg);
                const event = encode_decode_1.decode(msg);
                this.logger.warn(`[${correlationId}] Adding to dlq: ${this.dlqName} after ${retries} retries`);
                yield this.rabbit.publish(this.dlqName, event, msg.properties);
                const response = yield this.afterDlq({ msg, event });
                ack(msg.properties.headers.errors.message, response);
            }
            catch (err) {
                this.logger.error(err);
                yield this.rabbit.publish(this.dlqName, msg.content.toString(), msg.properties);
                ack(err.message, null);
            }
        });
    }
}
BaseQueueHandler.SCOPES = {
    singleton: 'SINGLETON',
    prototype: 'PROTOTYPE',
};
exports.default = BaseQueueHandler;
//# sourceMappingURL=base-queue-handler.js.map