"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const amqp = require("amqplib");
const events_1 = require("events");
const reply_queue_1 = require("./reply-queue");
const delay_queue_1 = require("./delay-queue");
const queue_1 = require("./queue");
const exchange_1 = require("./exchange");
const assert = require("assert");
const logger_1 = require("./logger");
class Rabbit extends events_1.EventEmitter {
    constructor(url, { prefetch = 1, replyPattern = true, prefix = '', scheduledPublish = false, socketOptions = {} } = {}) {
        super();
        this.url = url;
        this.queues = {};
        this.connecting = false;
        if (!Rabbit.INSTANCE) {
            Rabbit.INSTANCE = this;
        }
        this.logger = logger_1.default('rabbit-queue');
        assert(url, 'Url is required!');
        this.prefetch = prefetch;
        this.replyPattern = replyPattern;
        this.prefix = prefix;
        this.scheduledPublish = scheduledPublish;
        this.socketOptions = socketOptions;
        this.reconnect();
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.connecting) {
                return;
            }
            this.connecting = true;
            this.consumeConnection = yield amqp.connect(this.url, this.socketOptions);
            this.consumeChannel = yield this.createChannel(this.consumeConnection);
            yield this.initChannel(this.consumeChannel);
            this.publishConnection = yield amqp.connect(this.url, this.socketOptions);
            this.publishChannel = yield this.createChannel(this.publishConnection);
            yield this.initChannel(this.publishChannel, true);
            this.emit('connected');
            this.connecting = false;
        });
    }
    reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this.connected = this.connect();
            yield this.connected.catch((error) => this.emitDisconnected(error));
        });
    }
    emitDisconnected(error) {
        this.connecting = false;
        this.emit('disconnected', error);
    }
    createChannel(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            connection.once('close', (error) => this.emitDisconnected(error));
            connection.on('error', (error) => this.emitDisconnected(error));
            return connection.createConfirmChannel();
        });
    }
    initChannel(channel, publish = false) {
        return __awaiter(this, void 0, void 0, function* () {
            channel.prefetch(this.prefetch);
            channel.on('close', (error) => this.emitDisconnected(error));
            if (!publish && this.replyPattern) {
                yield reply_queue_1.createReplyQueue(this.consumeChannel);
            }
            if (!publish && this.scheduledPublish) {
                yield delay_queue_1.createDelayQueueReply(this.consumeChannel, this.updateName('delay'));
            }
        });
    }
    updateName(name, prefix = this.prefix) {
        if (prefix && prefix.length > 0) {
            if (name.startsWith('.')) {
                name = `${prefix}${name}`;
            }
            else if (!name.startsWith(`${prefix}_`) && !name.startsWith(`${prefix}.`)) {
                name = `${prefix}_${name}`;
            }
        }
        return name;
    }
    createQueue(name, options = {}, handler) {
        return __awaiter(this, void 0, void 0, function* () {
            options.prefetch = options.prefetch || this.prefetch;
            name = this.updateName(name, options.prefix);
            yield this.connected;
            const queue = new queue_1.default(this.consumeChannel, name, options);
            this.queues[name] = queue;
            yield queue.created;
            this.logger.debug(`created queue ${name}`);
            if (handler) {
                let localLock;
                do {
                    localLock = this.lock;
                    yield this.lock;
                } while (this.lock !== localLock);
                if (this.prefetch !== options.prefetch) {
                    this.prefetch = options.prefetch;
                    this.lock = Promise.resolve(this.consumeChannel.prefetch(options.prefetch)).then(() => queue.subscribe(handler));
                    yield this.lock;
                }
                else {
                    this.lock = queue.subscribe(handler);
                    yield this.lock;
                }
            }
            return queue;
        });
    }
    destroyQueue(name, prefix) {
        return __awaiter(this, void 0, void 0, function* () {
            name = this.updateName(name, prefix);
            yield this.connected;
            yield queue_1.default.destroy(this.consumeChannel, name);
        });
    }
    subscribe(name, handler, prefix) {
        return __awaiter(this, void 0, void 0, function* () {
            name = this.updateName(name, prefix);
            yield this.connected;
            yield this.queues[name].subscribe(handler);
        });
    }
    unsubscribe(name, prefix) {
        return __awaiter(this, void 0, void 0, function* () {
            name = this.updateName(name, prefix);
            yield this.connected;
            yield this.queues[name].unsubscribe();
        });
    }
    publish(name, obj, headers, prefix) {
        return __awaiter(this, void 0, void 0, function* () {
            name = this.updateName(name, prefix);
            yield this.connected;
            yield queue_1.default.publish(obj, headers, this.publishChannel, name, this.queues[name]);
        });
    }
    publishWithDelay(name, obj, properties, prefix) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.scheduledPublish) {
                throw new Error('scheduledPublish is not enabled');
            }
            name = this.updateName(name, prefix);
            yield this.connected;
            yield delay_queue_1.publishWithDelay(this.updateName('delay'), obj, properties, this.consumeChannel, name);
        });
    }
    getReply(name, obj, properties, prefix, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            name = this.updateName(name, prefix);
            yield this.connected;
            return yield queue_1.default.getReply(obj, properties, this.publishChannel, name, this.queues[name], timeout);
        });
    }
    getTopicReply(topicName, content, properties, prefix, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            topicName = this.updateName(topicName, prefix);
            yield this.connected;
            return yield exchange_1.default.getReply(this.publishChannel, 'amq.topic', topicName, content, properties, timeout);
        });
    }
    publishExchange(exchange, routingKey, content, headers, prefix) {
        return __awaiter(this, void 0, void 0, function* () {
            routingKey = this.updateName(routingKey, prefix);
            yield this.connected;
            yield exchange_1.default.publish(this.publishChannel, exchange, routingKey, content, headers);
        });
    }
    publishTopic(topicName, content, headers = {}, prefix) {
        return __awaiter(this, void 0, void 0, function* () {
            topicName = this.updateName(topicName, prefix);
            yield this.connected;
            yield exchange_1.default.publish(this.publishChannel, 'amq.topic', topicName, content, headers);
        });
    }
    bindToExchange(queueName, exchange, routingKey, prefix) {
        return __awaiter(this, void 0, void 0, function* () {
            queueName = this.updateName(queueName, prefix);
            yield this.connected;
            yield queue_1.default.bindToExchange(exchange, routingKey, this.consumeChannel, queueName, this.queues[queueName]);
        });
    }
    unbindFromExchange(queueName, exchange, topicName, prefix) {
        return __awaiter(this, void 0, void 0, function* () {
            queueName = this.updateName(queueName, prefix);
            yield this.connected;
            yield queue_1.default.unbindFromExchange(exchange, topicName, this.consumeChannel, queueName, this.queues[queueName]);
        });
    }
    bindToTopic(queueName, topicName, prefix) {
        return __awaiter(this, void 0, void 0, function* () {
            queueName = this.updateName(queueName, prefix);
            yield this.bindToExchange(queueName, 'amq.topic', topicName, prefix);
        });
    }
    unbindFromTopic(queueName, topicName, prefix) {
        return __awaiter(this, void 0, void 0, function* () {
            queueName = this.updateName(queueName, prefix);
            yield this.unbindFromExchange(queueName, 'amq.topic', topicName, prefix);
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.consumeConnection.close();
            yield this.publishConnection.close();
        });
    }
}
exports.default = Rabbit;
Rabbit.STOP_PROPAGATION = queue_1.default.STOP_PROPAGATION;
Rabbit.STOP_STREAM = queue_1.default.STOP_STREAM;
//# sourceMappingURL=rabbit.js.map