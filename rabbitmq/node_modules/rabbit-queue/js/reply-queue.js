"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const uuid = require("uuid");
const queue_1 = require("./queue");
const stream_1 = require("stream");
const encode_decode_1 = require("./encode-decode");
const logger_1 = require("./logger");
const logger = logger_1.default('rabbit-queue');
let replyHandlers = {};
let streamHandlers = {};
let stopped = {};
let options = { channel: null };
function createReplyQueue(channel) {
    return __awaiter(this, void 0, void 0, function* () {
        yield channel.assertQueue('', { exclusive: true }).then(replyTo => {
            channel.replyName = replyTo.queue;
            options.channel = channel;
            channel.consume(channel.replyName, onReply, { noAck: true });
        });
    });
}
exports.createReplyQueue = createReplyQueue;
function addHandler(correlationId, handler) {
    assert(!replyHandlers[correlationId], `Already added reply handler with this id: ${correlationId}.`);
    assert(!streamHandlers[correlationId], `Already exists stream handler with this id: ${correlationId}.`);
    replyHandlers[correlationId] = handler;
}
exports.addHandler = addHandler;
function getReply(content, properties = {}, channel, cb) {
    return new Promise((resolve, reject) => {
        var correlationId = properties.correlationId || uuid.v4();
        properties = Object.assign({
            persistent: false,
            correlationId,
            replyTo: options.channel.replyName,
            contentType: 'application/json'
        }, properties);
        const bufferContent = encode_decode_1.encode(content, properties.contentType);
        addHandler(correlationId, (err, body) => (err ? reject(err) : resolve(body)));
        cb(bufferContent, properties, correlationId, (err, ok) => (err ? reject(err) : {}));
    });
}
exports.getReply = getReply;
function onReply(msg) {
    const id = msg.properties.correlationId;
    const headers = msg.properties.headers || {};
    if (headers.isStream) {
        return handleStreamReply(msg, headers.correlationId);
    }
    const replyHandler = replyHandlers[id];
    if (!replyHandler) {
        logger.error(`No reply Handler found for ${id}`);
        return;
    }
    delete replyHandlers[id];
    logger.info(`[${id}] <- Returning reply ${msg.content.byteLength} bytes`);
    const obj = encode_decode_1.decode(msg);
    if (obj && obj.error && obj.error_code === queue_1.default.ERROR_DURING_REPLY.error_code) {
        replyHandler(new Error(obj.error_message), null);
    }
    else {
        replyHandler(null, obj);
    }
}
function handleStreamReply(msg, id) {
    const correlationId = msg.properties.correlationId;
    const replyHandler = replyHandlers[id];
    let streamHandler = streamHandlers[id];
    let backpressure = false;
    if (replyHandler && streamHandler) {
        delete replyHandlers[id];
        return replyHandler(new Error(`Both replyHandler and StreamHandler exist for id: ${id}`));
    }
    if (!streamHandler) {
        if (!replyHandler) {
            logger.error(`No reply Handler found for ${id}`);
            return;
        }
        delete replyHandlers[id];
        streamHandler = new stream_1.Readable({
            objectMode: true,
            read() {
                backpressure = false;
                if (options[id]) {
                    const { replyTo, properties } = options[id];
                    if (replyTo)
                        options.channel.sendToQueue(replyTo, encode_decode_1.encode({ backpressure: true }), properties);
                    delete options[id];
                }
            }
        });
        streamHandler.on(queue_1.default.STOP_STREAM, () => {
            stopped[id] = true;
        });
        streamHandlers[id] = streamHandler;
        replyHandler(null, streamHandler);
    }
    const obj = encode_decode_1.decode(msg);
    if (obj && obj.error && obj.error_code === queue_1.default.ERROR_DURING_REPLY.error_code) {
        delete streamHandlers[id];
        return setImmediate(() => streamHandler.destroy(new Error(obj.error_message)));
    }
    logger.info(`[${correlationId}] <- Returning${(obj === null && ' the end of') || ''} stream reply ${msg.content.byteLength} bytes`);
    const properties = {
        correlationId,
        contentType: 'application/json',
        persistent: false
    };
    if (stopped[id]) {
        options.channel.sendToQueue(msg.properties.replyTo, Buffer.from(JSON.stringify(queue_1.default.STOP_STREAM_MESSAGE)), properties);
        streamHandler.push(null);
        delete options[id];
        delete stopped[id];
        delete streamHandlers[id];
        logger.info(`[${correlationId}] <- Returning (stop event received) the end of stream reply ${msg.content.byteLength} bytes`);
        return;
    }
    backpressure = !streamHandler.push(obj);
    if (backpressure) {
        options[id] = { replyTo: msg.properties.replyTo, properties };
    }
    else if (msg.properties.replyTo) {
        options.channel.sendToQueue(msg.properties.replyTo, encode_decode_1.encode(null), properties);
    }
    if (obj === null) {
        delete streamHandlers[id];
    }
}
//# sourceMappingURL=reply-queue.js.map